{"ast":null,"code":"import { HttpErrorResponse } from '@angular/common/http';\nimport { catchError, throwError } from 'rxjs';\nimport { AuthUtils } from 'app/core/auth/auth.utils';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"app/core/auth/auth.service\";\nclass AuthInterceptor {\n  /**\n   * Constructor\n   */\n  constructor(_authService) {\n    this._authService = _authService;\n  }\n  /**\n   * Intercept\n   *\n   * @param req\n   * @param next\n   */\n  intercept(req, next) {\n    // Clone the request object\n    let newReq = req.clone();\n    // Request\n    //\n    // If the access token didn't expire, add the Authorization header.\n    // We won't add the Authorization header if the access token expired.\n    // This will force the server to return a \"401 Unauthorized\" response\n    // for the protected API routes which our response interceptor will\n    // catch and delete the access token from the local storage while logging\n    // the user out from the app.\n    if (this._authService.accessToken && !AuthUtils.isTokenExpired(this._authService.accessToken)) {\n      newReq = req.clone({\n        headers: req.headers.set('Authorization', 'Bearer ' + this._authService.accessToken)\n      });\n    }\n    // Response\n    return next.handle(newReq).pipe(catchError(error => {\n      // Catch \"401 Unauthorized\" responses\n      if (error instanceof HttpErrorResponse && error.status === 401) {\n        // Sign out\n        this._authService.signOut();\n        // Reload the app\n        location.reload();\n      }\n      return throwError(error);\n    }));\n  }\n  static #_ = this.ɵfac = function AuthInterceptor_Factory(t) {\n    return new (t || AuthInterceptor)(i0.ɵɵinject(i1.AuthService));\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AuthInterceptor,\n    factory: AuthInterceptor.ɵfac\n  });\n}\nexport { AuthInterceptor };","map":{"version":3,"names":["HttpErrorResponse","catchError","throwError","AuthUtils","AuthInterceptor","constructor","_authService","intercept","req","next","newReq","clone","accessToken","isTokenExpired","headers","set","handle","pipe","error","status","signOut","location","reload","_","i0","ɵɵinject","i1","AuthService","_2","factory","ɵfac"],"sources":["C:\\Users\\jcfaz\\Downloads\\Projects\\desafio-afiliado\\front\\src\\app\\core\\auth\\auth.interceptor.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { HttpErrorResponse, HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from '@angular/common/http';\r\nimport { catchError, Observable, throwError } from 'rxjs';\r\nimport { AuthService } from 'app/core/auth/auth.service';\r\nimport { AuthUtils } from 'app/core/auth/auth.utils';\r\n\r\n@Injectable()\r\nexport class AuthInterceptor implements HttpInterceptor\r\n{\r\n    /**\r\n     * Constructor\r\n     */\r\n    constructor(private _authService: AuthService)\r\n    {\r\n    }\r\n\r\n    /**\r\n     * Intercept\r\n     *\r\n     * @param req\r\n     * @param next\r\n     */\r\n    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>>\r\n    {\r\n        // Clone the request object\r\n        let newReq = req.clone();\r\n\r\n        // Request\r\n        //\r\n        // If the access token didn't expire, add the Authorization header.\r\n        // We won't add the Authorization header if the access token expired.\r\n        // This will force the server to return a \"401 Unauthorized\" response\r\n        // for the protected API routes which our response interceptor will\r\n        // catch and delete the access token from the local storage while logging\r\n        // the user out from the app.\r\n        if ( this._authService.accessToken && !AuthUtils.isTokenExpired(this._authService.accessToken) )\r\n        {\r\n            newReq = req.clone({\r\n                headers: req.headers.set('Authorization', 'Bearer ' + this._authService.accessToken)\r\n            });\r\n        }\r\n\r\n        // Response\r\n        return next.handle(newReq).pipe(\r\n            catchError((error) => {\r\n\r\n                // Catch \"401 Unauthorized\" responses\r\n                if ( error instanceof HttpErrorResponse && error.status === 401 )\r\n                {\r\n                    // Sign out\r\n                    this._authService.signOut();\r\n\r\n                    // Reload the app\r\n                    location.reload();\r\n                }\r\n\r\n                return throwError(error);\r\n            })\r\n        );\r\n    }\r\n}\r\n"],"mappings":"AACA,SAASA,iBAAiB,QAA8D,sBAAsB;AAC9G,SAASC,UAAU,EAAcC,UAAU,QAAQ,MAAM;AAEzD,SAASC,SAAS,QAAQ,0BAA0B;;;AAEpD,MACaC,eAAe;EAExB;;;EAGAC,YAAoBC,YAAyB;IAAzB,KAAAA,YAAY,GAAZA,YAAY;EAEhC;EAEA;;;;;;EAMAC,SAASA,CAACC,GAAqB,EAAEC,IAAiB;IAE9C;IACA,IAAIC,MAAM,GAAGF,GAAG,CAACG,KAAK,EAAE;IAExB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAK,IAAI,CAACL,YAAY,CAACM,WAAW,IAAI,CAACT,SAAS,CAACU,cAAc,CAAC,IAAI,CAACP,YAAY,CAACM,WAAW,CAAC,EAC9F;MACIF,MAAM,GAAGF,GAAG,CAACG,KAAK,CAAC;QACfG,OAAO,EAAEN,GAAG,CAACM,OAAO,CAACC,GAAG,CAAC,eAAe,EAAE,SAAS,GAAG,IAAI,CAACT,YAAY,CAACM,WAAW;OACtF,CAAC;;IAGN;IACA,OAAOH,IAAI,CAACO,MAAM,CAACN,MAAM,CAAC,CAACO,IAAI,CAC3BhB,UAAU,CAAEiB,KAAK,IAAI;MAEjB;MACA,IAAKA,KAAK,YAAYlB,iBAAiB,IAAIkB,KAAK,CAACC,MAAM,KAAK,GAAG,EAC/D;QACI;QACA,IAAI,CAACb,YAAY,CAACc,OAAO,EAAE;QAE3B;QACAC,QAAQ,CAACC,MAAM,EAAE;;MAGrB,OAAOpB,UAAU,CAACgB,KAAK,CAAC;IAC5B,CAAC,CAAC,CACL;EACL;EAAC,QAAAK,CAAA,G;qBApDQnB,eAAe,EAAAoB,EAAA,CAAAC,QAAA,CAAAC,EAAA,CAAAC,WAAA;EAAA;EAAA,QAAAC,EAAA,G;WAAfxB,eAAe;IAAAyB,OAAA,EAAfzB,eAAe,CAAA0B;EAAA;;SAAf1B,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}