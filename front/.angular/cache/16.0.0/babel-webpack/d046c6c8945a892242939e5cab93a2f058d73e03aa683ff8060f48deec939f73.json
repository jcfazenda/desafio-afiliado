{"ast":null,"code":"import { catchError, of, switchMap, throwError } from 'rxjs';\nimport { AuthUtils } from 'app/core/auth/auth.utils';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"app/core/user/user.service\";\nclass AuthService {\n  /**\n   * Constructor\n   */\n  constructor(_httpClient, _userService) {\n    this._httpClient = _httpClient;\n    this._userService = _userService;\n    this._authenticated = false;\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Accessors\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Setter & getter for access token\n   */\n  set accessToken(token) {\n    localStorage.setItem('accessToken', token);\n  }\n  get accessToken() {\n    return localStorage.getItem('accessToken') ?? '';\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Public methods\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Forgot password\n   *\n   * @param email\n   */\n  forgotPassword(email) {\n    return this._httpClient.post('api/auth/forgot-password', email);\n  }\n  /**\n   * Reset password\n   *\n   * @param password\n   */\n  resetPassword(password) {\n    return this._httpClient.post('api/auth/reset-password', password);\n  }\n  /**\n   * Sign in\n   *\n   * @param credentials\n   */\n  signIn(credentials) {\n    // Throw error, if the user is already logged in\n    if (this._authenticated) {\n      return throwError('User is already logged in.');\n    }\n    return this._httpClient.post('api/auth/sign-in', credentials).pipe(switchMap(response => {\n      // Store the access token in the local storage\n      this.accessToken = response.accessToken;\n      // Set the authenticated flag to true\n      this._authenticated = true;\n      // Store the user on the user service\n      this._userService.user = response.user;\n      // Return a new observable with the response\n      return of(response);\n    }));\n  }\n  /**\n   * Sign in using the access token\n   */\n  signInUsingToken() {\n    // Sign in using the token\n    return this._httpClient.post('api/auth/sign-in-with-token', {\n      accessToken: this.accessToken\n    }).pipe(catchError(() =>\n    // Return false\n    of(false)), switchMap(response => {\n      // Replace the access token with the new one if it's available on\n      // the response object.\n      //\n      // This is an added optional step for better security. Once you sign\n      // in using the token, you should generate a new one on the server\n      // side and attach it to the response object. Then the following\n      // piece of code can replace the token with the refreshed one.\n      if (response.accessToken) {\n        this.accessToken = response.accessToken;\n      }\n      // Set the authenticated flag to true\n      this._authenticated = true;\n      // Store the user on the user service\n      this._userService.user = response.user;\n      // Return true\n      return of(true);\n    }));\n  }\n  /**\n   * Sign out\n   */\n  signOut() {\n    // Remove the access token from the local storage\n    localStorage.removeItem('accessToken');\n    // Set the authenticated flag to false\n    this._authenticated = false;\n    // Return the observable\n    return of(true);\n  }\n  /**\n   * Sign up\n   *\n   * @param user\n   */\n  signUp(user) {\n    return this._httpClient.post('api/auth/sign-up', user);\n  }\n  /**\n   * Unlock session\n   *\n   * @param credentials\n   */\n  unlockSession(credentials) {\n    return this._httpClient.post('api/auth/unlock-session', credentials);\n  }\n  /**\n   * Check the authentication status\n   */\n  check() {\n    // Check if the user is logged in\n    if (this._authenticated) {\n      return of(true);\n    }\n    // Check the access token availability\n    if (!this.accessToken) {\n      return of(false);\n    }\n    // Check the access token expire date\n    if (AuthUtils.isTokenExpired(this.accessToken)) {\n      return of(false);\n    }\n    // If the access token exists and it didn't expire, sign in using it\n    return this.signInUsingToken();\n  }\n  static #_ = this.ɵfac = function AuthService_Factory(t) {\n    return new (t || AuthService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.UserService));\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AuthService,\n    factory: AuthService.ɵfac\n  });\n}\nexport { AuthService };","map":{"version":3,"names":["catchError","of","switchMap","throwError","AuthUtils","AuthService","constructor","_httpClient","_userService","_authenticated","accessToken","token","localStorage","setItem","getItem","forgotPassword","email","post","resetPassword","password","signIn","credentials","pipe","response","user","signInUsingToken","signOut","removeItem","signUp","unlockSession","check","isTokenExpired","_","i0","ɵɵinject","i1","HttpClient","i2","UserService","_2","factory","ɵfac"],"sources":["C:\\Users\\jcfaz\\Downloads\\Projects\\desafio-afiliado\\front\\src\\app\\core\\auth\\auth.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { catchError, Observable, of, switchMap, throwError } from 'rxjs';\r\nimport { AuthUtils } from 'app/core/auth/auth.utils';\r\nimport { UserService } from 'app/core/user/user.service';\r\n\r\n@Injectable()\r\nexport class AuthService\r\n{\r\n    private _authenticated: boolean = false;\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    constructor(\r\n        private _httpClient: HttpClient,\r\n        private _userService: UserService\r\n    )\r\n    {\r\n    }\r\n\r\n    // -----------------------------------------------------------------------------------------------------\r\n    // @ Accessors\r\n    // -----------------------------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Setter & getter for access token\r\n     */\r\n    set accessToken(token: string)\r\n    {\r\n        localStorage.setItem('accessToken', token);\r\n    }\r\n\r\n    get accessToken(): string\r\n    {\r\n        return localStorage.getItem('accessToken') ?? '';\r\n    }\r\n\r\n    // -----------------------------------------------------------------------------------------------------\r\n    // @ Public methods\r\n    // -----------------------------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Forgot password\r\n     *\r\n     * @param email\r\n     */\r\n    forgotPassword(email: string): Observable<any>\r\n    {\r\n        return this._httpClient.post('api/auth/forgot-password', email);\r\n    }\r\n\r\n    /**\r\n     * Reset password\r\n     *\r\n     * @param password\r\n     */\r\n    resetPassword(password: string): Observable<any>\r\n    {\r\n        return this._httpClient.post('api/auth/reset-password', password);\r\n    }\r\n\r\n    /**\r\n     * Sign in\r\n     *\r\n     * @param credentials\r\n     */\r\n    signIn(credentials: { email: string; password: string }): Observable<any>\r\n    {\r\n        // Throw error, if the user is already logged in\r\n        if ( this._authenticated )\r\n        {\r\n            return throwError('User is already logged in.');\r\n        }\r\n\r\n        return this._httpClient.post('api/auth/sign-in', credentials).pipe(\r\n            switchMap((response: any) => {\r\n\r\n                // Store the access token in the local storage\r\n                this.accessToken = response.accessToken;\r\n\r\n                // Set the authenticated flag to true\r\n                this._authenticated = true;\r\n\r\n                // Store the user on the user service\r\n                this._userService.user = response.user;\r\n\r\n                // Return a new observable with the response\r\n                return of(response);\r\n            })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sign in using the access token\r\n     */\r\n    signInUsingToken(): Observable<any>\r\n    {\r\n        // Sign in using the token\r\n        return this._httpClient.post('api/auth/sign-in-with-token', {\r\n            accessToken: this.accessToken\r\n        }).pipe(\r\n            catchError(() =>\r\n\r\n                // Return false\r\n                of(false)\r\n            ),\r\n            switchMap((response: any) => {\r\n\r\n                // Replace the access token with the new one if it's available on\r\n                // the response object.\r\n                //\r\n                // This is an added optional step for better security. Once you sign\r\n                // in using the token, you should generate a new one on the server\r\n                // side and attach it to the response object. Then the following\r\n                // piece of code can replace the token with the refreshed one.\r\n                if ( response.accessToken )\r\n                {\r\n                    this.accessToken = response.accessToken;\r\n                }\r\n\r\n                // Set the authenticated flag to true\r\n                this._authenticated = true;\r\n\r\n                // Store the user on the user service\r\n                this._userService.user = response.user;\r\n\r\n                // Return true\r\n                return of(true);\r\n            })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sign out\r\n     */\r\n    signOut(): Observable<any>\r\n    {\r\n        // Remove the access token from the local storage\r\n        localStorage.removeItem('accessToken');\r\n\r\n        // Set the authenticated flag to false\r\n        this._authenticated = false;\r\n\r\n        // Return the observable\r\n        return of(true);\r\n    }\r\n\r\n    /**\r\n     * Sign up\r\n     *\r\n     * @param user\r\n     */\r\n    signUp(user: { name: string; email: string; password: string; company: string }): Observable<any>\r\n    {\r\n        return this._httpClient.post('api/auth/sign-up', user);\r\n    }\r\n\r\n    /**\r\n     * Unlock session\r\n     *\r\n     * @param credentials\r\n     */\r\n    unlockSession(credentials: { email: string; password: string }): Observable<any>\r\n    {\r\n        return this._httpClient.post('api/auth/unlock-session', credentials);\r\n    }\r\n\r\n    /**\r\n     * Check the authentication status\r\n     */\r\n    check(): Observable<boolean>\r\n    {\r\n        // Check if the user is logged in\r\n        if ( this._authenticated )\r\n        {\r\n            return of(true);\r\n        }\r\n\r\n        // Check the access token availability\r\n        if ( !this.accessToken )\r\n        {\r\n            return of(false);\r\n        }\r\n\r\n        // Check the access token expire date\r\n        if ( AuthUtils.isTokenExpired(this.accessToken) )\r\n        {\r\n            return of(false);\r\n        }\r\n\r\n        // If the access token exists and it didn't expire, sign in using it\r\n        return this.signInUsingToken();\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}