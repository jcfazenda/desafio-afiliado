{"ast":null,"code":"// -----------------------------------------------------------------------------------------------------\n// @ AUTH UTILITIES\n//\n// Methods are derivations of the Auth0 Angular-JWT helper service methods\n// https://github.com/auth0/angular2-jwt\n// -----------------------------------------------------------------------------------------------------\nexport class AuthUtils {\n  /**\n   * Constructor\n   */\n  constructor() {}\n  // -----------------------------------------------------------------------------------------------------\n  // @ Public methods\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Is token expired?\n   *\n   * @param token\n   * @param offsetSeconds\n   */\n  static isTokenExpired(token, offsetSeconds) {\n    // Return if there is no token\n    if (!token || token === '') {\n      return true;\n    }\n    // Get the expiration date\n    const date = this._getTokenExpirationDate(token);\n    offsetSeconds = offsetSeconds || 0;\n    if (date === null) {\n      return true;\n    }\n    // Check if the token is expired\n    return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Private methods\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Base64 decoder\n   * Credits: https://github.com/atk\n   *\n   * @param str\n   * @private\n   */\n  static _b64decode(str) {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    let output = '';\n    str = String(str).replace(/=+$/, '');\n    if (str.length % 4 === 1) {\n      throw new Error('\\'atob\\' failed: The string to be decoded is not correctly encoded.');\n    }\n    /* eslint-disable */\n    for (\n    // initialize result and counters\n    let bc = 0, bs, buffer, idx = 0;\n    // get next character\n    buffer = str.charAt(idx++);\n    // character found in table? initialize bit storage and add its ascii value;\n    ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n    // and if not first of each 4 characters,\n    // convert the first 8 bits to one ascii character\n    bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {\n      // try to find character in table (0-63, not found => -1)\n      buffer = chars.indexOf(buffer);\n    }\n    /* eslint-enable */\n    return output;\n  }\n  /**\n   * Base64 unicode decoder\n   *\n   * @param str\n   * @private\n   */\n  static _b64DecodeUnicode(str) {\n    return decodeURIComponent(Array.prototype.map.call(this._b64decode(str), c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));\n  }\n  /**\n   * URL Base 64 decoder\n   *\n   * @param str\n   * @private\n   */\n  static _urlBase64Decode(str) {\n    let output = str.replace(/-/g, '+').replace(/_/g, '/');\n    switch (output.length % 4) {\n      case 0:\n        {\n          break;\n        }\n      case 2:\n        {\n          output += '==';\n          break;\n        }\n      case 3:\n        {\n          output += '=';\n          break;\n        }\n      default:\n        {\n          throw Error('Illegal base64url string!');\n        }\n    }\n    return this._b64DecodeUnicode(output);\n  }\n  /**\n   * Decode token\n   *\n   * @param token\n   * @private\n   */\n  static _decodeToken(token) {\n    // Return if there is no token\n    if (!token) {\n      return null;\n    }\n    // Split the token\n    const parts = token.split('.');\n    if (parts.length !== 3) {\n      throw new Error('The inspected token doesn\\'t appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.');\n    }\n    // Decode the token using the Base64 decoder\n    const decoded = this._urlBase64Decode(parts[1]);\n    if (!decoded) {\n      throw new Error('Cannot decode the token.');\n    }\n    return JSON.parse(decoded);\n  }\n  /**\n   * Get token expiration date\n   *\n   * @param token\n   * @private\n   */\n  static _getTokenExpirationDate(token) {\n    // Get the decoded token\n    const decodedToken = this._decodeToken(token);\n    // Return if the decodedToken doesn't have an 'exp' field\n    if (!decodedToken.hasOwnProperty('exp')) {\n      return null;\n    }\n    // Convert the expiration date\n    const date = new Date(0);\n    date.setUTCSeconds(decodedToken.exp);\n    return date;\n  }\n}","map":{"version":3,"names":["AuthUtils","constructor","isTokenExpired","token","offsetSeconds","date","_getTokenExpirationDate","valueOf","Date","_b64decode","str","chars","output","String","replace","length","Error","bc","bs","buffer","idx","charAt","fromCharCode","indexOf","_b64DecodeUnicode","decodeURIComponent","Array","prototype","map","call","c","charCodeAt","toString","slice","join","_urlBase64Decode","_decodeToken","parts","split","decoded","JSON","parse","decodedToken","hasOwnProperty","setUTCSeconds","exp"],"sources":["C:\\Users\\jcfaz\\OneDrive\\Ãrea de Trabalho\\projects\\payments\\iso\\src\\app\\core\\auth\\auth.utils.ts"],"sourcesContent":["// -----------------------------------------------------------------------------------------------------\r\n// @ AUTH UTILITIES\r\n//\r\n// Methods are derivations of the Auth0 Angular-JWT helper service methods\r\n// https://github.com/auth0/angular2-jwt\r\n// -----------------------------------------------------------------------------------------------------\r\n\r\nexport class AuthUtils\r\n{\r\n    /**\r\n     * Constructor\r\n     */\r\n    constructor()\r\n    {\r\n    }\r\n\r\n    // -----------------------------------------------------------------------------------------------------\r\n    // @ Public methods\r\n    // -----------------------------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Is token expired?\r\n     *\r\n     * @param token\r\n     * @param offsetSeconds\r\n     */\r\n    static isTokenExpired(token: string, offsetSeconds?: number): boolean\r\n    {\r\n        // Return if there is no token\r\n        if ( !token || token === '' )\r\n        {\r\n            return true;\r\n        }\r\n\r\n        // Get the expiration date\r\n        const date = this._getTokenExpirationDate(token);\r\n\r\n        offsetSeconds = offsetSeconds || 0;\r\n\r\n        if ( date === null )\r\n        {\r\n            return true;\r\n        }\r\n\r\n        // Check if the token is expired\r\n        return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\r\n    }\r\n\r\n    // -----------------------------------------------------------------------------------------------------\r\n    // @ Private methods\r\n    // -----------------------------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Base64 decoder\r\n     * Credits: https://github.com/atk\r\n     *\r\n     * @param str\r\n     * @private\r\n     */\r\n    private static _b64decode(str: string): string\r\n    {\r\n        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\r\n        let output = '';\r\n\r\n        str = String(str).replace(/=+$/, '');\r\n\r\n        if ( str.length % 4 === 1 )\r\n        {\r\n            throw new Error(\r\n                '\\'atob\\' failed: The string to be decoded is not correctly encoded.'\r\n            );\r\n        }\r\n\r\n        /* eslint-disable */\r\n        for (\r\n            // initialize result and counters\r\n            let bc = 0, bs: any, buffer: any, idx = 0;\r\n            // get next character\r\n            (buffer = str.charAt(idx++));\r\n            // character found in table? initialize bit storage and add its ascii value;\r\n            ~buffer &&\r\n            (\r\n                (bs = bc % 4 ? bs * 64 + buffer : buffer),\r\n                    // and if not first of each 4 characters,\r\n                    // convert the first 8 bits to one ascii character\r\n                bc++ % 4\r\n            )\r\n                ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\r\n                : 0\r\n        )\r\n        {\r\n            // try to find character in table (0-63, not found => -1)\r\n            buffer = chars.indexOf(buffer);\r\n        }\r\n        /* eslint-enable */\r\n\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * Base64 unicode decoder\r\n     *\r\n     * @param str\r\n     * @private\r\n     */\r\n    private static _b64DecodeUnicode(str: any): string\r\n    {\r\n        return decodeURIComponent(\r\n            Array.prototype.map\r\n                 .call(this._b64decode(str), (c: any) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\r\n                 .join('')\r\n        );\r\n    }\r\n\r\n    /**\r\n     * URL Base 64 decoder\r\n     *\r\n     * @param str\r\n     * @private\r\n     */\r\n    private static _urlBase64Decode(str: string): string\r\n    {\r\n        let output = str.replace(/-/g, '+').replace(/_/g, '/');\r\n        switch ( output.length % 4 )\r\n        {\r\n            case 0:\r\n            {\r\n                break;\r\n            }\r\n            case 2:\r\n            {\r\n                output += '==';\r\n                break;\r\n            }\r\n            case 3:\r\n            {\r\n                output += '=';\r\n                break;\r\n            }\r\n            default:\r\n            {\r\n                throw Error('Illegal base64url string!');\r\n            }\r\n        }\r\n        return this._b64DecodeUnicode(output);\r\n    }\r\n\r\n    /**\r\n     * Decode token\r\n     *\r\n     * @param token\r\n     * @private\r\n     */\r\n    private static _decodeToken(token: string): any\r\n    {\r\n        // Return if there is no token\r\n        if ( !token )\r\n        {\r\n            return null;\r\n        }\r\n\r\n        // Split the token\r\n        const parts = token.split('.');\r\n\r\n        if ( parts.length !== 3 )\r\n        {\r\n            throw new Error('The inspected token doesn\\'t appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.');\r\n        }\r\n\r\n        // Decode the token using the Base64 decoder\r\n        const decoded = this._urlBase64Decode(parts[1]);\r\n\r\n        if ( !decoded )\r\n        {\r\n            throw new Error('Cannot decode the token.');\r\n        }\r\n\r\n        return JSON.parse(decoded);\r\n    }\r\n\r\n    /**\r\n     * Get token expiration date\r\n     *\r\n     * @param token\r\n     * @private\r\n     */\r\n    private static _getTokenExpirationDate(token: string): Date | null\r\n    {\r\n        // Get the decoded token\r\n        const decodedToken = this._decodeToken(token);\r\n\r\n        // Return if the decodedToken doesn't have an 'exp' field\r\n        if ( !decodedToken.hasOwnProperty('exp') )\r\n        {\r\n            return null;\r\n        }\r\n\r\n        // Convert the expiration date\r\n        const date = new Date(0);\r\n        date.setUTCSeconds(decodedToken.exp);\r\n\r\n        return date;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}