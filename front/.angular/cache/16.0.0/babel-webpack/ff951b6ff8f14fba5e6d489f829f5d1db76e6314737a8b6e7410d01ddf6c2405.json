{"ast":null,"code":"import { map, ReplaySubject, switchMap, take, tap } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nclass MessagesService {\n  /**\n   * Constructor\n   */\n  constructor(_httpClient) {\n    this._httpClient = _httpClient;\n    this._messages = new ReplaySubject(1);\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Accessors\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Getter for messages\n   */\n  get messages$() {\n    return this._messages.asObservable();\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Public methods\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Get all messages\n   */\n  getAll() {\n    return this._httpClient.get('api/common/messages').pipe(tap(messages => {\n      this._messages.next(messages);\n    }));\n  }\n  /**\n   * Create a message\n   *\n   * @param message\n   */\n  create(message) {\n    return this.messages$.pipe(take(1), switchMap(messages => this._httpClient.post('api/common/messages', {\n      message\n    }).pipe(map(newMessage => {\n      // Update the messages with the new message\n      this._messages.next([...messages, newMessage]);\n      // Return the new message from observable\n      return newMessage;\n    }))));\n  }\n  /**\n   * Update the message\n   *\n   * @param id\n   * @param message\n   */\n  update(id, message) {\n    return this.messages$.pipe(take(1), switchMap(messages => this._httpClient.patch('api/common/messages', {\n      id,\n      message\n    }).pipe(map(updatedMessage => {\n      // Find the index of the updated message\n      const index = messages.findIndex(item => item.id === id);\n      // Update the message\n      messages[index] = updatedMessage;\n      // Update the messages\n      this._messages.next(messages);\n      // Return the updated message\n      return updatedMessage;\n    }))));\n  }\n  /**\n   * Delete the message\n   *\n   * @param id\n   */\n  delete(id) {\n    return this.messages$.pipe(take(1), switchMap(messages => this._httpClient.delete('api/common/messages', {\n      params: {\n        id\n      }\n    }).pipe(map(isDeleted => {\n      // Find the index of the deleted message\n      const index = messages.findIndex(item => item.id === id);\n      // Delete the message\n      messages.splice(index, 1);\n      // Update the messages\n      this._messages.next(messages);\n      // Return the deleted status\n      return isDeleted;\n    }))));\n  }\n  /**\n   * Mark all messages as read\n   */\n  markAllAsRead() {\n    return this.messages$.pipe(take(1), switchMap(messages => this._httpClient.get('api/common/messages/mark-all-as-read').pipe(map(isUpdated => {\n      // Go through all messages and set them as read\n      messages.forEach((message, index) => {\n        messages[index].read = true;\n      });\n      // Update the messages\n      this._messages.next(messages);\n      // Return the updated status\n      return isUpdated;\n    }))));\n  }\n  static #_ = this.ɵfac = function MessagesService_Factory(t) {\n    return new (t || MessagesService)(i0.ɵɵinject(i1.HttpClient));\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: MessagesService,\n    factory: MessagesService.ɵfac,\n    providedIn: 'root'\n  });\n}\nexport { MessagesService };","map":{"version":3,"names":["map","ReplaySubject","switchMap","take","tap","MessagesService","constructor","_httpClient","_messages","messages$","asObservable","getAll","get","pipe","messages","next","create","message","post","newMessage","update","id","patch","updatedMessage","index","findIndex","item","delete","params","isDeleted","splice","markAllAsRead","isUpdated","forEach","read","_","i0","ɵɵinject","i1","HttpClient","_2","factory","ɵfac","providedIn"],"sources":["C:\\Users\\jcfaz\\Downloads\\Projects\\desafio-afiliado\\front\\src\\app\\layout\\common\\messages\\messages.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { map, Observable, ReplaySubject, switchMap, take, tap } from 'rxjs';\r\nimport { Message } from 'app/layout/common/messages/messages.types';\r\n\r\n@Injectable({\r\n    providedIn: 'root'\r\n})\r\nexport class MessagesService\r\n{\r\n    private _messages: ReplaySubject<Message[]> = new ReplaySubject<Message[]>(1);\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    constructor(private _httpClient: HttpClient)\r\n    {\r\n    }\r\n\r\n    // -----------------------------------------------------------------------------------------------------\r\n    // @ Accessors\r\n    // -----------------------------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Getter for messages\r\n     */\r\n    get messages$(): Observable<Message[]>\r\n    {\r\n        return this._messages.asObservable();\r\n    }\r\n\r\n    // -----------------------------------------------------------------------------------------------------\r\n    // @ Public methods\r\n    // -----------------------------------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Get all messages\r\n     */\r\n    getAll(): Observable<Message[]>\r\n    {\r\n        return this._httpClient.get<Message[]>('api/common/messages').pipe(\r\n            tap((messages) => {\r\n                this._messages.next(messages);\r\n            })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Create a message\r\n     *\r\n     * @param message\r\n     */\r\n    create(message: Message): Observable<Message>\r\n    {\r\n        return this.messages$.pipe(\r\n            take(1),\r\n            switchMap(messages => this._httpClient.post<Message>('api/common/messages', {message}).pipe(\r\n                map((newMessage) => {\r\n\r\n                    // Update the messages with the new message\r\n                    this._messages.next([...messages, newMessage]);\r\n\r\n                    // Return the new message from observable\r\n                    return newMessage;\r\n                })\r\n            ))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Update the message\r\n     *\r\n     * @param id\r\n     * @param message\r\n     */\r\n    update(id: string, message: Message): Observable<Message>\r\n    {\r\n        return this.messages$.pipe(\r\n            take(1),\r\n            switchMap(messages => this._httpClient.patch<Message>('api/common/messages', {\r\n                id,\r\n                message\r\n            }).pipe(\r\n                map((updatedMessage: Message) => {\r\n\r\n                    // Find the index of the updated message\r\n                    const index = messages.findIndex(item => item.id === id);\r\n\r\n                    // Update the message\r\n                    messages[index] = updatedMessage;\r\n\r\n                    // Update the messages\r\n                    this._messages.next(messages);\r\n\r\n                    // Return the updated message\r\n                    return updatedMessage;\r\n                })\r\n            ))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Delete the message\r\n     *\r\n     * @param id\r\n     */\r\n    delete(id: string): Observable<boolean>\r\n    {\r\n        return this.messages$.pipe(\r\n            take(1),\r\n            switchMap(messages => this._httpClient.delete<boolean>('api/common/messages', {params: {id}}).pipe(\r\n                map((isDeleted: boolean) => {\r\n\r\n                    // Find the index of the deleted message\r\n                    const index = messages.findIndex(item => item.id === id);\r\n\r\n                    // Delete the message\r\n                    messages.splice(index, 1);\r\n\r\n                    // Update the messages\r\n                    this._messages.next(messages);\r\n\r\n                    // Return the deleted status\r\n                    return isDeleted;\r\n                })\r\n            ))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Mark all messages as read\r\n     */\r\n    markAllAsRead(): Observable<boolean>\r\n    {\r\n        return this.messages$.pipe(\r\n            take(1),\r\n            switchMap(messages => this._httpClient.get<boolean>('api/common/messages/mark-all-as-read').pipe(\r\n                map((isUpdated: boolean) => {\r\n\r\n                    // Go through all messages and set them as read\r\n                    messages.forEach((message, index) => {\r\n                        messages[index].read = true;\r\n                    });\r\n\r\n                    // Update the messages\r\n                    this._messages.next(messages);\r\n\r\n                    // Return the updated status\r\n                    return isUpdated;\r\n                })\r\n            ))\r\n        );\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}